也许你还记得我曾经写过的[Node.js静态文件服务器实战](http://www.infoq.com/cn/news/2011/11/tyq-nodejs-static-file-server)，那篇文章中我叙述了如何利用Node.js实现一个静态文件服务器的许多技术细节，包括路由实现，MIME，缓存控制，传输压缩，安全、欢迎页、断点续传等。但是这里我们不需要去亲自处理细节，`Connect`的`static`中间件为我们提供上述所有功能。代码只需寥寥3行即可：

```
var connect = require('connect');  
var app = connect(); 
app.use(connect.static(__dirname + '/public')); 
```

在项目中需要临时搭建静态服务器，也无需安装apache之类的服务器，通过NPM安装Connect之后，三行代码即可解决需求。

这里需要提及的是在使用该模块的一点性能相关的细节。

### 动静分离

前一章提及，`app.use()`方法在没有指定路由信息时，相当于`app.use("/", middleware)`。这意味着静态文件中间件将会在处理所有路径的请求。在动静态请求混杂的场景下，静态中间件会在动态请求时也调用`fs.stat`来检测文件系统是否存在静态文件。这造成了不必要的系统调用，使得性能降低。

解决影响性能的方法既是动静分离。利用路由检测，避免不必要的系统调用，可以有效降低对动态请求的性能影响。

```
app.use('/public', connect.static(__dirname + '/public'));
```

在大型的应用中，动静分离通常无需到一个Node.js实例中进行，CDN的方式直接在域名上将请求分离。小型应用中，适当的进行动静分离即可避免不必要的性能损耗



### 缓存策略

缓存策略包含客户端和服务端两个部分。

客户端的缓存，主要是利用浏览器对HTTP协议响应头中`cache-control`和`expires`字段的支持。浏览器在得到明确的相应头后，会将文件缓存在本地，依据`cache-control`和`expires`的值进行相应的过期策略。这使得重复访问的过程中，浏览器可以从本地缓存中读取文件，而无需从网络读取文件，提升加载速度，也可以降低对服务器的压力。

默认情况下静态中间件的最大缓存时设置为0，意味着它在浏览器关闭后就被清除。这显然不是我们所期望的结果。除非是在开发环境可以无视`maxAge`的设置外，生产环境请务必设置缓存，因为它能有效节省网络带宽。

```
app.use('/public', connect.static(__dirname + '/public', {maxAge: 86400000})); 
```

`maxAge`选项的单位为毫秒。YUI3的CDN服务器设置过期时间为10年，是一个值得参考的值。

静态文件如果在客户端被缓存，在需要清除缓存的时候，又该如何清除呢？这里的实现方法较多，一种较为推荐的做法是为文件进行md5处理。

```
http://some.url/some.js?md5 
```

当文件内容产生改变时，md5值也将发生改变，浏览器根据URL的不同会重新获取静态文件。md5的方式可以避免不必要的缓存清除，也能精确清除缓存。

由于浏览器本身缓存容量的限制，尽管我们可能设置了10年的过期时间，但是也许两天之后就被新的静态文件挤出了本地缓存。这将持续引起静态服务器的响应，也即意味着，客户端缓存并不能完全解决降低服务器压力的问题。

为了解决静态服务器重复读取磁盘造成的压力，这里需要引出第二个相关的中间件：`staticCache`。

```
app.use(connect.staticCache());  
app.use(“/public”, connect.static(__dirname + '/public', {maxAge: 86400000})); 
```

这是一个提供上层缓存功能的中间件，能够将磁盘中的文件加载到内存中，以提高响应速度和提高性能。

它的官方测试数据如下：

```
static(): 2700 rps 
node-static: 5300 rps 
static() + staticCache(): 7500 rps 
```

另一个专门用于静态文件托管的模块叫`node-static`，其性能是Connect静态文件中间件的效率的两倍。但是在缓存中间件的协助下，可以弥补性能损失。

事实上，这个中间件在生产环境下并不推荐被使用，而且它将在Connect 3.0版本中被移除。但是它的实现中有值得玩味的地方，这有助于我们认识Node.js模型的优缺点。

`staticCache`中间件有两个主要的选项：`maxObjects`和`maxLength`。代表的是能存储多少个文件和单个文件的最大尺寸，其默认值为128和256kb。为何会有这两个选项的设定，原因在于V8有内存限制的原因，作为缓存，如果没有良好的过期策略，缓存将会无限增加，直到内存溢出。设置存储数量和单个文件大小后，可以有效抑制缓存区的大小。

事实上，该缓存还存在的缺陷是单机情况下，通常为了有效利用CPU，Node.js实例并不只有一个，多个实例进程之间将会存在冗余的缓存占用，这对于内存使用而言是浪费的。

除此之外，V8的垃圾回收机制是暂停JavaScript线程执行，通过扫描的方式决定是否回收对象。如果缓存对象过大，键太多，则扫描的时间会增加，会引起JavaScript响应业务逻辑的速度变慢。

但是这个模块并非没有存在的意义，上述提及的缺陷大多都是V8内存限制和Node.js单线程的原因。解决该问题的方式则变得明了。

_**风险转移**_是Node.js中常用于解决资源不足问题的方式，尤其是内存方面的问题。将缓存点，从Node.js实例进程中转移到第三方成熟的缓存中去即可。这可以保证：

1. 缓存内容不冗余。
2. 集中式缓存，减少不一致性的发生。
3. 缓存的算法更优秀以保持较高的命中率。
4. 让Node.js保持轻量，以解决它更擅长的问题。

Connect推荐服务器端缓存采用`varnish`这样的成熟缓存代理。而笔者目前的项目则是通过`Redis`来完成后端缓存的任务。

# 参考内容

* [https:\/\/www.varnish-cache.org\/releases](https://www.varnish-cache.org/releases)
* [http:\/\/www.senchalabs.org\/connect\/static.html](http://www.senchalabs.org/connect/static.html)
* [http:\/\/www.senchalabs.org\/connect\/staticCache.html](http://www.senchalabs.org/connect/staticCache.html)

